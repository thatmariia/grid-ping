:py:mod:`GridConnectivity`
==========================

.. py:module:: GridConnectivity


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   GridConnectivity.GridConnectivity




.. py:class:: GridConnectivity(nr_neurons, nr_ping_networks, cortical_coords)

   This class constructs the connectivity matrix for the oscillatory network.

   The interaction strength of lateral connections is represented by a matrix :math:`K` of pairwise coupling weights
   defined by an exponential function decaying by the Euclidean distance between the PING networks they belong to:

   :math:`K_{v, w} = C_{ \mathsf{type}(v), \mathsf{type}(w)} \exp (-\| \mathsf{loc}(v), \mathsf{loc}(w) \| / s_{v, w}),`

   where

   * :math:`v, w` are two arbitrary neurons in the network,
   * :math:`\mathsf{type}(v)` maps a neuron to its type (see :obj:`NeuronTypes`),
   * :math:`\mathsf{loc}(v)` maps a neuron to its location on the grid,
   * :math:`s_{v, w}` is the spatial constant (see :obj:`constants.SPATIAL_CONST`).

   This equation was introduced in :cite:p:`Izhikevich2003`.

   This class performs the assignment of neurons to relevant PING networks arranged in a grid and computes the matrix
   of coupling weights.


   :param nr_neurons: number of neurons of each type in the network.
   :type nr_neurons: dict[NeuronTypes, int]

   :param nr_ping_networks: number of PING networks in the network.
   :type nr_ping_networks: int

   :param cortical_coords: locations of PING networks in the visual cortex.
   :type cortical_coords: list[list[tuple[float, float]]]


   :raises:
       AssertionError: If the number of PING networks is smaller than 1.
   :raises:
       AssertionError: if number of excitatory neurons doesn't divide the number of PING networks as there should be
       an equal number of excitatory neurons in each PING network.
   :raises:
       AssertionError: if number of inhibitory neurons doesn't divide the number of PING networks as there should be
       an equal number of inhibitory neurons in each PING network.
   :raises:
       AssertionError: if the number of PING networks is not a square as PING networks should be arranged in a square
       grid.


   :ivar _nr_neurons: number of neurons of each type in the network.
   :type _nr_neurons: dict[NeuronTypes, int]

   :ivar _nr_ping_networks: number of ping_networks in the network.
   :type _nr_ping_networks: int

   :ivar _cortical_coords: locations of PING networks in the visual cortex.
   :type _cortical_coords: list[list[tuple[float, float]]]

   :ivar coupling_weights: Matrix of all coupling weights.
   :type coupling_weights: np.ndarray[(int, int), float]

   .. py:method:: _assign_ping_networks(self) -> tuple[list[src.PINGNetworkNeurons.PINGNetworkNeurons], dict[src.constants.NeuronTypes, dict[int, int]]]

      Creates PING networks, assigns grid locations to them, and adds the same number of neurons of each neuron type
      to them.

      In other words, this function creates a map that can be used as function :math:`\mathsf{loc}`.

      :return: list of PING networks in the network and a dictionary mapping a neuron to the PING network it belongs
          to.
      :rtype: tuple[list[PINGNetworkNeurons], dict[NeuronTypes, dict[int, int]]]


   .. py:method:: _compute_coupling_weights(self, ping_networks: list[src.PINGNetworkNeurons.PINGNetworkNeurons], neuron_ping_map: dict[src.constants.NeuronTypes, dict[int, int]]) -> src.misc.np.ndarray[(int, int), float]

      Computes the coupling weights between all neurons.

      Essentially, this method computes the full matrix :math:`K` of coupling weights.

      :param ping_networks: list of PING networks in the network.
      :type ping_networks: list[PINGNetworkNeurons]

      :param neuron_ping_map: a dictionary mapping a neuron to the PING network it belongs to.
      :type neuron_ping_map: dict[NeuronTypes, dict[int, int]]

      :return: matrix of all coupling weights.
      :rtype: numpy.ndarray[(int, int), float]


   .. py:method:: _get_neurons_dist(self, neuron_type1: src.constants.NeuronTypes, neuron_type2: src.constants.NeuronTypes, nr1: int, nr2: int, ping_networks: list[src.PINGNetworkNeurons.PINGNetworkNeurons], neuron_ping_map: dict[src.constants.NeuronTypes, dict[int, int]]) -> src.misc.np.ndarray[(int, int), float]

      Computes the matrix of Euclidian distances between two types of neurons.

      This method computes a matrix of :math:`\| \mathsf{loc}(v), \mathsf{loc}(w) \|` between neurons :math:`v` and
      :math:`w` of given types.

      :param neuron_type1: neurons neuron_type 1
      :type neuron_type1: NeuronTypes

      :param neuron_type2: neurons neuron_type 2
      :type neuron_type2: NeuronTypes

      :param nr1: number of neurons of neuron_type 1
      :type nr1: int

      :param nr2: number of neurons of neuron_type 2
      :type nr2: int

      :param ping_networks: list of PING networks in the network.
      :type ping_networks: list[PINGNetworkNeurons]

      :param neuron_ping_map: a dictionary mapping a neuron to the PING network it belongs to.
      :type neuron_ping_map: dict[NeuronTypes, dict[int, int]]

      :return: The matrix nr1 x nr2 of pairwise distances between neurons.
      :rtype: numpy.ndarray[(int, int), float]


   .. py:method:: _compute_type_coupling_weights(self, dist: src.misc.np.ndarray[(int, int), float], max_connect_strength: float, spatial_const: float) -> src.misc.np.ndarray[(int, int), float]

      Computes the coupling weights for connections between two types of neurons.

      This method computes a matrix of :math:`K_{v, w}` between neurons :math:`v` and
      :math:`w` of given types.

      :param dist: distance matrix with pairwise distances between neurons.
      :type dist: numpy.ndarray[(int, int), float]

      :param max_connect_strength: max connection strength between neuron types.
      :type max_connect_strength: float

      :param spatial_const: spatial constant for the neuron types.
      :type spatial_const: float

      :return: the matrix of coupling weights of size nr1 x nr2, where n1 and nr2 - number of neurons of
          each neuron_type in the coupling of interest.
      :rtype: numpy.ndarray[(int, int), float]



