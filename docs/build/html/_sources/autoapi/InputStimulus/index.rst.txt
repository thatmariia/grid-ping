:py:mod:`InputStimulus`
=======================

.. py:module:: InputStimulus


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   InputStimulus.InputStimulus




.. py:class:: InputStimulus(spatial_freq: float, vlum: float, diameter_dg: float, diameter: int, dist_scale: float, full_width_dg: float, full_height_dg: float, contrast_range: float, figure_width_dg: float, figure_height_dg: float, figure_ecc_dg: float, patch_size_dg: float, nr_circuits: int, slope: float, intercept: float, min_diam_rf: float)

   Bases: :py:obj:`src.GaborLuminanceStimulus.GaborLuminanceStimulus`

   This class transforms a luminance stimulus patch to current.

   TODO:: more elaborate explanation + ref.

   :param spatial_freq: spatial frequency of the grating (cycles / degree).
   :type spatial_freq: float

   :param vlum: luminance of the void.
   :type vlum: float

   :param diameter_dg: annulus' diameter in degrees.
   :type diameter_dg: float

   :param diameter: resolution (number of pixels in a single row) of single grating.
   :type diameter: int

   :param dist_scale: how far the circles are from each other.
   :type dist_scale: float

   :param full_width_dg: width of the full stimulus in degrees.
   :type full_width_dg: float

   :param full_height_dg: height of the full stimulus in degrees.
   :type full_height_dg: float

   :param contrast_range: contrast range for the figure.
   :type contrast_range: float

   :param figure_width_dg: width of the figure in degrees.
   :type figure_width_dg: float

   :param figure_height_dg: height of the figure in degrees.
   :type figure_height_dg: float

   :param figure_ecc_dg: distance between the center of the stimulus and the center of the figure in degrees.
   :type figure_ecc_dg: float

   :param patch_size_dg: side length of the stimulus patch in degrees.
   :type patch_size_dg: float

   :param nr_circuits: number of circuits created by applying the lattice.
   :type nr_circuits: int

   :param slope: slope of the receptive field size.
   :type slope: float

   :param intercept: intercept of the receptive field size.
   :type intercept: float

   :param min_diam_rf: minimal size of the receptive field.
   :type min_diam_rf: float


   :raises:
       AssertionError: if the minimal diameter of the receptive field is not larger than 0.
   :raises:
       AssertionError: if the number of circuits is not a square as these circuits should be arranged in a square
       grid.
   :raises:
       AssertionError: if vertical lines of lattice cut through pixels.
   :raises:
       AssertionError: if horizontal lines of lattice cut through pixels.


   :ivar _nr_circuits: number of circuits created by applying the lattice.
   :type _nr_circuits: int

   :ivar _circuits: list of info about circuits.
   :type _circuits: list[StimulusCircuit]

   :ivar current: list of currents produced by respective circuits in the stimulus.
   :type current: numpy.ndarray[int, float]

   .. py:method:: _assign_circuits(self) -> list[src.StimulusCircuit.StimulusCircuit]

      Creates circuits and assigns centers and pixels of the stimulus patch to them.

      :return: list of all circuits of the stimulus patch created by applying a lattice.
      :rtype: list[StimulusCircuit]


   .. py:method:: extract_stimulus_location(self) -> src.StimulusLocations.StimulusLocations

      Computes the location info of the stimulus patch and, thus, the PING networks, namely eccentricity and
      angle of each PING network.

      :return: location info of the network.
      :rtype: StimulusLocations


   .. py:method:: _get_input_current(self, slope: float, intercept: float, min_diam_rf: float) -> numpy.ndarray[int, float]

      Performs all the necessary steps to transform luminance to current.

      :param slope: slope of the receptive field size.
      :type slope: float

      :param intercept: intercept of the receptive field size.
      :type intercept: float

      :param min_diam_rf: minimal size of the receptive field.
      :type min_diam_rf: float

      :return: list containing currents created by each circuit.
      :rtype: numpy.ndarray[int, float]


   .. py:method:: _get_weight(self, center: tuple[float, float], pixel: tuple[int, int], eccentricity: float, slope: float, intercept: float, min_diam_rf: float) -> float

      Computes weight of a pixel with respect to a circuit.

      :param center: coordinate of the circuit center.
      :type center: tuple[float, float]

      :param pixel: coordinate of the pixel.
      :type pixel: tuple[float, float]

      :param eccentricity: eccentricity of the circuit center.
      :type eccentricity: float

      :param slope: slope of the receptive field size.
      :type slope: float

      :param intercept: intercept of the receptive field size.
      :type intercept: float

      :param min_diam_rf: minimal size of the receptive field.
      :type min_diam_rf: float

      :return: weight of a pixel with respect to a circuit.
      :rtype: float


   .. py:method:: _point_in_stimulus(self, point: tuple[float, float]) -> tuple[float, Ellipsis]

      Calculates the coordinate of a given point in the patch within the stimulus.

      :param point: coordinates of the point within the patch in degrees.
      :type point: tuple[float, float]

      :return: coordinates of the point within the stimulus in degrees.
      :rtype: tuple[float, float]


   .. py:method:: _angle_in_patch(self, point: tuple[float, float]) -> float

      Calculates the angle between the horizontal axis and the line passing through the center of the stimulus and a
      given point within the patch.

      :param point: coordinates of the point within the patch in degrees.
      :type point: tuple[float, float]

      :return: angle of the point.
      :rtype: float


   .. py:method:: _eccentricity_in_patch(self, point: tuple[float, float]) -> float

      Calculates eccentricity at the given point within the patch.

      :param point: coordinates of the point within the patch in degrees.
      :type point: tuple[float, float]

      :return: eccentricity in degrees.
      :rtype: float


   .. py:method:: _compute_local_contrasts(self, slope: float, intercept: float, min_diam_rf: float) -> list[float]

      Computes local contrasts for each circuit.

      :param slope: slope of the receptive field size.
      :type slope: float

      :param intercept: intercept of the receptive field size.
      :type intercept: float

      :param min_diam_rf: minimal size of the receptive field.
      :type min_diam_rf: float

      :return: list containing local contrast values for each circuit.
      :rtype: list[float]


   .. py:method:: _compute_frequencies(self, local_contrasts: list[float]) -> numpy.ndarray[int, float]

      Computes oscillation frequencies of the circuit through local contrasts.

      :param local_contrasts: list containing local contrast values for each circuit.
      :type local_contrasts: list[float]

      :return: list containing oscillation frequencies for each circuit.
      :rtype: numpy.ndarray[int, float]


   .. py:method:: _compute_current(self, frequencies: numpy.ndarray[int, float]) -> numpy.ndarray[int, float]

      Computes _currents through oscillation frequencies. ARTIFICIAL FUNCTION - REAL NOT IMPLEMENTED YET.

      :param frequencies: list containing oscillation frequencies for each circuit.
      :type frequencies: list[float]

      :return: TODO
      :rtype: numpy.ndarray[int, float]



